#include "CDetector/CDetector.hpp"
#include "CGenerator/CGenerator.hpp"
#include "Miscellanous/misc.hpp"

#include <algorithm>
#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <ios>
#include <iostream>
#include <new>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

#include <boost/program_options.hpp>
#include <matio.h>
#include <omp.h>

#include "config.h"
#include "utility_functions.hpp"

using std::complex;
using std::string;
using std::vector;

using complexf = complex<float>;

namespace po = boost::program_options;

using namespace QCSP::StandaloneDetector;
using namespace QCSP::StandaloneDetector::Simulators;
using namespace QCSP::StandaloneDetector::Utilities;

using std::cerr;
using std::endl;

/*********************************************/
/* Constants Definitions *********************/
/*********************************************/
static constexpr int  cst_q       = @TARGET_Q@;
static constexpr int  cst_N       = @TARGET_N@;
static constexpr int  cst_p_omega = @TARGET_W@;
static constexpr bool normed      = @TARGET_NORMED@;

typedef int16_t INTYPE;

/*********************************************/
/* Constants Deductions **********************/
/*********************************************/
static constexpr int   actual_p_omega = cst_p_omega + int(cst_p_omega == 0);
static constexpr float default_span   = two_pi_f * float(cst_p_omega) / std::max(float((cst_p_omega >> 1) << 1), 1.f) * float(cst_p_omega > 0);
static constexpr int   default_step   = (cst_p_omega >> int(is_odd<int, cst_p_omega>()));

static constexpr CorrelationEngineType correngine = TIME_SLIDING;

#cmakedefine01 USE_MULT
#if defined(USE_MULT) && (USE_MULT == 1)
#error "Mult detector is not implemented."
#define TDetector    CDetectorSerialMult
#define STR_DETECTOR "tsmult"
#else
#define TDetector    CDetectorSerial
#define STR_DETECTOR "ts"
#endif

using detector_t = TDetector<cst_N, cst_q, actual_p_omega, INTYPE, normed, correngine>;
using state_t    = detector_t::state_t;

int main(int argc, char * argv[]) {
    static_assert(cst_p_omega >= 0, "p_omega cannot be negative.");
    static_assert(is_pow2(cst_q), "q must be a power of 2.");
    static_assert(cst_N == 60, "cst_N must be 60.");

    po::options_description desc("Options");
    desc.add_options()(
        "help,h", "produce help message")(
        "snr,s", po::value<float>()->default_value(-10.f), "targeted signal-to-noise ratio")(
        "runs,n", po::value<int>()->default_value(10), "number of monte-carlo runs")(
        "pn-file", po::value<string>()->required(), "pn sequence mat file to use")(
        "ovmod-file", po::value<string>()->required(), "overmodulation sequence file to use")(
        "alist-file", po::value<string>()->required(), "alist file to use")(
        "threads,t", po::value<int>()->default_value(1), "number of threads to use")(
        "threshold,H", po::value<float>()->default_value((cst_N * pow2_log2<cst_q*cst_q>()) / 2.f), "threshold to use in detection (no effect if complete is not specified)")(
        "rotation-span", po::value<float>()->default_value(default_span), "rotation span to use. For a value X, rotation will be in the interval [-X/2, X/2]")(
        "step-numerator", po::value<unsigned>()->default_value(1U), "step numerator to use")(
        "step-denominator", po::value<unsigned>()->default_value(default_step), "step denominator to use")(
        "complete", "simulate a complete detector instead of a partially inhibited one (WARNING: THRESHOLD MATTERS)")(
        "no-fa", "disable False Alarm scenario")(
        "no-md", "disable Miss Detection scenario")(
        "full-score", "log the full score instead of only the maximum one (WARNING: LARGE FILES AND HEAVY PERFORMANCE IMPACT)")(
        "output-file,o", po::value<string>()->default_value(DEFAULT_SCORE_FILE), "score file to write");

    po::variables_map vm;
    try {
        po::store(po::command_line_parser(argc, argv)
                      .options(desc)
                      .run(),
                  vm);

        if (vm.count("help")) {
            std::cout << "Usage: " << argv[0] << " [options]\n"
                      << desc << std::endl;
            return 1;
        }

        po::notify(vm);
    } catch (std::exception & e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    const float snr = vm["snr"].as<float>();

    const int threads = std::max(vm["threads"].as<int>(), 1);

    // const int p_delta = vm["p_delta"].as<int>();

    const string alist_path = vm["alist-file"].as<string>();

    FILE * alist_file = fopen(alist_path.c_str(), "r");
    if (!bool(alist_file)) {
        error_stream << "Can't open alist file " << alist_path << "\n  "
                     << strerror(errno) << endl;
        exit(EXIT_FAILURE);
    }

    int       N, M, q;
    const int nmq_read = fscanf(alist_file, "%d %d %d", &N, &M, &q);
    if (nmq_read != 3) {
        error_stream << "Alist file " << alist_path << " seems ill-formed:\n"
                     << "  Failed to read \"N M q\" from it." << endl;
        fclose(alist_file);
        exit(EXIT_FAILURE);
    }

    fclose(alist_file);

    if (q != cst_q) {
        error_stream << "q value (" << q
                     << ") is not currently the one the program have been compiled for (" << cst_q << ").\n"
                     << "You may have to reconfigure and rebuild the project to fix that." << std::endl;
        return 1;
    }

    if (N != cst_N) {
        error_stream << "N value (" << N
                     << ") is not currently the one the program have been compiled for (" << cst_N << ").\n"
                     << "You may have to reconfigure and rebuild the project to fix that." << std::endl;
        return 1;
    }

    const string pn_path = vm["pn-file"].as<string>();
    mat_t *      pn_file = Mat_Open(pn_path.c_str(), MAT_ACC_RDONLY);
    if (!bool(pn_file)) {
        error_stream << "Can't open pn mat file " << pn_path << endl;
        exit(EXIT_FAILURE);
    }

    const string pn_name = "PN" + std::to_string(cst_q);
    matvar_t *   pn_var  = Mat_VarRead(pn_file, pn_name.c_str());
    if (!bool(pn_var)) {
        error_stream << "Can't find pn mat variable " << pn_name << " in " << pn_path << endl;
        Mat_Close(pn_file);
        exit(EXIT_FAILURE);
    }

    const float * pn_data = (float *) pn_var->data;
    const size_t  pn_size = pn_var->dims[1];

    if (pn_size != size_t(q)) {
        error_stream << "alist q (" << q << ") and size of "
                     << pn_name << " in " << pn_path << " (" << pn_size << ") don't match." << endl;
        Mat_VarFree(pn_var);
        Mat_Close(pn_file);
        exit(EXIT_FAILURE);
    }

    const vector<float> pn(pn_data, pn_data + cst_q);

    Mat_VarFree(pn_var);
    Mat_Close(pn_file);

    const string ovmod_path = vm["ovmod-file"].as<string>();
    mat_t *      ovmod_file = Mat_Open(ovmod_path.c_str(), MAT_ACC_RDONLY);
    if (!bool(ovmod_file)) {
        error_stream << "Can't open ovmod mat file " << ovmod_path << endl;
        exit(EXIT_FAILURE);
    }

    const string ovmod_name = "best_N";
    matvar_t *   ovmod_var  = Mat_VarRead(ovmod_file, ovmod_name.c_str());
    if (!bool(ovmod_var)) {
        error_stream << "Can't find ovmod mat variable " << ovmod_name << " in " << ovmod_path << endl;
        Mat_Close(ovmod_file);
        exit(EXIT_FAILURE);
    }

    const double * ovmod_data = (double *) ovmod_var->data;
    const size_t   ovmod_size = ovmod_var->dims[1];

    if (ovmod_size != size_t(N)) {
        error_stream << "alist N (" << N << ") and size of "
                     << ovmod_name << " in " << ovmod_path << " (" << ovmod_size << ") don't match." << endl;
        Mat_VarFree(ovmod_var);
        Mat_Close(ovmod_file);
        exit(EXIT_FAILURE);
    }

    const vector<float> ovmod(ovmod_data, ovmod_data + N);

    Mat_VarFree(ovmod_var);
    Mat_Close(ovmod_file);

    const float rotation_span = vm["rotation-span"].as<float>();

    using frame_param_t = CGenerator::frame_param_t;

    vector<CGenerator> generators;
    for (int t = 0; t < threads; t++) {
        generators.emplace_back(alist_path, pn, ovmod, snr, rotation_span);
    }

    const float    flt_threshold    = vm["threshold"].as<float>();
    const uint32_t threshold        = (uint32_t) round(flt_threshold * 2);
    const int      step_numerator   = int(vm["step-numerator"].as<unsigned>() & ~(1U << 31));
    const int      step_denominator = int(vm["step-denominator"].as<unsigned>() & ~(1U << 31));

    vector<detector_t> detectors;
    for (int t = 0; t < threads; t++) {
        detectors.emplace_back(pn.data(), threshold, step_denominator, step_numerator);
    }

    const bool full_score = vm.count("full-score");

    const int runs           = vm["runs"].as<int>() * int(vm["runs"].as<int>() > 0);
    const int run_per_thread = int(float(runs) / float(threads * int(!full_score) + int(full_score)));

    if (run_per_thread * threads != runs) {
        error_stream << "A total number of run (" << runs << ") not divisible by the number of threads(" << threads << ") is not supported." << endl;
        exit(EXIT_FAILURE);
    }

    constexpr int frame_size = detector_t::window_size;
    constexpr int run_length = frame_size * 5;

    constexpr int64_t max_batch_size = (1 << (10 * 3)) / sizeof(float);

    const int max_batch_thread = int(ceilf(float(max_batch_size) / float(threads)));
    const int batch_size       = std::min(max_batch_thread, run_per_thread);

    vector<unsigned> inner_counters(threads, 0U);

    vector<vector<uint32_t>> inner_memories(
        threads,
        vector<uint32_t>(
            batch_size,
            0.f));

    const bool do_fa = !vm.count("no-fa");
    const bool do_md = !vm.count("no-md");

    const int runs_md = runs * int(do_md);
    const int runs_fa = runs * int(do_fa);

    const bool complete = vm.count("complete");

    string output_path = vm["output-file"].as<string>();
    if (output_path == DEFAULT_SCORE_FILE) {
        std::ostringstream os;
        os << "score_fa_md_" << STR_DETECTOR
           << (normed ? "_normed" : "_raw");

        if (complete) {
            os << "_H" << std::setprecision(2) << threshold;
        } else {
            os << "_classic";
        }

        os << "_@TARGET_INTYPE@"
           << "_snr" << std::setprecision(5) << snr
           << "_q" << cst_q
           << "_d" << cst_q
           << "_w" << actual_p_omega
           << "_step" << step_numerator
           << "_" << step_denominator
           << "_span" << std::setprecision(5) << rotation_span / pi_f
           << ".mat";

        output_path = os.str();
    }

    mat_t * score_mat = Mat_Open(output_path.c_str(), MAT_ACC_RDWR);
    if (!bool(score_mat)) {
        warning_stream << "Can't open score mat file " << output_path << " for writing. Trying to create it..." << endl;
        score_mat = Mat_CreateVer(output_path.c_str(), nullptr, MAT_FT_MAT73);
        if (!bool(score_mat)) {
            error_stream << "Can't create the score mat file " << output_path << " for writing. terminating..." << endl;
            exit(EXIT_FAILURE);
        }

        constexpr size_t var_size = 9;

        size_t dims[2]             = {1UL, var_size};
        float  file_info[var_size] = {
             (float) USE_MULT,
             (float) normed,
             (float) (complete ? threshold : -1.f),
             (float) snr,
             (float) q,
             (float) q,
             (float) actual_p_omega,
             (float) detectors[0].rotation_step(),
             (float) rotation_span};
        matvar_t * mat_file_info = Mat_VarCreate("file_info", MAT_C_SINGLE, MAT_T_SINGLE, 2, dims, file_info, 0);

        Mat_VarWrite(score_mat, mat_file_info, MAT_COMPRESSION_ZLIB);

        Mat_VarFree(mat_file_info);

        info_stream << "File " << output_path << " created and initialized." << endl;
    }

    omp_lock_t lock_file;
    omp_init_lock(&lock_file);

    size_t runs_done = 0LU;

    const int run_md_per_thread = run_per_thread * int(do_md);
    const int run_fa_per_thread = run_per_thread * int(do_fa);

    const size_t cond_update_md = low_sat_1(size_t(run_md_per_thread / 100));
    const size_t cond_update_fa = low_sat_1(size_t(run_fa_per_thread / 100));

#pragma omp parallel num_threads(threads) if ((threads > 1) && !full_score) shared(score_mat)
    {

#pragma omp single nowait
        {
            if (do_md) {
                info_stream << "Launching `Miss Detection` scenario." << endl;
            } else {
                info_stream << "`Miss Detection` scenario ignored." << endl;
            }
        }

#pragma omp for schedule(static, run_md_per_thread)
        for (int i = 0; i < runs_md; i++) {
            const int thread_id = omp_get_thread_num();

            vector<complexf> noisy_sequence;
            vector<uint32_t> max_scores(run_length);

            vector<vector<uint32_t>> score_full(run_length, vector<uint32_t>(actual_p_omega));

            state_t state {};
            state.frame_detected      = false;
            state.max_found           = false;
            state.max_score           = 0U;
            state.frequency_offset    = 0.f;
            state.frequency_index     = 0;
            state.chip_from_max       = 0;
            state.chip_since_last_det = 0;
            std::memset(state.scores, 0, actual_p_omega * sizeof(uint32_t));

            const frame_param_t params = generators[thread_id].generate<MD>(noisy_sequence);

            for (int chip = 0; chip < run_length; chip++) {
                const float flt_re_in = noisy_sequence[chip].real();
                const float flt_im_in = noisy_sequence[chip].imag();

                const int16_t re_in = (int16_t) round(flt_re_in * float(1 << (16 - 4)));
                const int16_t im_in = (int16_t) round(flt_im_in * float(1 << (16 - 4)));

                state.frame_detected = state.frame_detected && complete;

                detectors[thread_id].process_sqr(re_in, im_in, &state);

                max_scores[chip] = state.max_score;
                memcpy(score_full[chip].data(), state.scores, actual_p_omega * sizeof(uint32_t));
            }

            const auto iter_max_score = std::max_element(max_scores.begin() + 2 * frame_size + params.delay, max_scores.begin() + 4 * frame_size + params.delay);

            const unsigned current_counter             = inner_counters[thread_id]++;
            inner_memories[thread_id][current_counter] = *iter_max_score;

            if (full_score) {
                safe_write_full_score(score_full, score_mat, &lock_file);
            }

            if (current_counter >= inner_memories[thread_id].size() - 1) {
                inner_counters[thread_id] = 0U;
                safe_write_score_md(inner_memories[thread_id], score_mat, &lock_file);
            }

            if (thread_id == 0) {
                const size_t done = runs_done++;
                if (done % cond_update_md == 0) {
                    progressBar(done, run_md_per_thread);
                }
            }
        }

#pragma omp single
        {
            omp_set_lock(&lock_file);
            for (int thread_id = 0; thread_id < threads; thread_id++) {
                const unsigned counter = inner_counters[thread_id];
                if (counter != 0U) {
                    debug_print("There is remains in thread " << thread_id);
                    const auto iter = inner_memories[thread_id].cbegin();

                    const vector<uint32_t> remains(iter, iter + counter);
                    write_score_md(remains, score_mat);
                }
                inner_counters[thread_id] = 0U;
            }
            omp_unset_lock(&lock_file);

            runs_done = 0ULL;
            progressBar(1U, 1U);
            printf("\n\n");
        }

#pragma omp single nowait
        {
            if (do_fa) {
                info_stream << "Launching `False Alarm` scenario." << endl;
            } else {
                info_stream << "`False Alarm` scenario ignored." << endl;
            }
        }

#pragma omp for schedule(static, run_fa_per_thread)
        for (int i = 0; i < runs_fa; i++) {
            const int thread_id = omp_get_thread_num();

            vector<complexf> noisy_sequence;
            vector<uint32_t> max_scores(run_length);

            vector<vector<uint32_t>> score_full(run_length, vector<uint32_t>(actual_p_omega));

            state_t state {};
            state.frame_detected      = false;
            state.max_found           = false;
            state.max_score           = 0U;
            state.frequency_offset    = 0.f;
            state.frequency_index     = 0;
            state.chip_from_max       = 0;
            state.chip_since_last_det = 0;
            std::memset(state.scores, 0, actual_p_omega * sizeof(uint32_t));

            const frame_param_t params = generators[thread_id].generate<FA>(noisy_sequence);

            for (int chip = 0; chip < run_length; chip++) {
                const float flt_re_in = noisy_sequence[chip].real();
                const float flt_im_in = noisy_sequence[chip].imag();

                const int16_t re_in = (int16_t) round(flt_re_in * float(1 << (16 - 4)));
                const int16_t im_in = (int16_t) round(flt_im_in * float(1 << (16 - 4)));

                state.frame_detected = state.frame_detected && complete;

                detectors[thread_id].process_sqr(re_in, im_in, &state);

                max_scores[chip] = state.max_score;
                memcpy(score_full[chip].data(), state.scores, actual_p_omega * sizeof(uint32_t));
            }

            const auto iter_max_score = std::max_element(max_scores.begin() + 2 * frame_size + params.delay, max_scores.begin() + 2 * frame_size + params.delay);

            const unsigned current_counter             = inner_counters[thread_id]++;
            inner_memories[thread_id][current_counter] = *iter_max_score;

            if (full_score) {
                safe_write_full_score(score_full, score_mat, &lock_file);
            }

            if (current_counter >= inner_memories[thread_id].size() - 1) {
                inner_counters[thread_id] = 0U;
                safe_write_score_fa(inner_memories[thread_id], score_mat, &lock_file);
            }

            if (thread_id == 0) {
                const size_t done = runs_done++;
                if (done % cond_update_fa == 0) {
                    progressBar(done, run_fa_per_thread);
                }
            }
        }

#pragma omp single nowait
        {
            omp_set_lock(&lock_file);
            for (int thread_id = 0; thread_id < threads; thread_id++) {
                const unsigned counter = inner_counters[thread_id];
                if (counter != 0U) {
                    debug_print("There is remains in thread " << thread_id);
                    const auto iter = inner_memories[thread_id].cbegin();

                    const vector<uint32_t> remains(iter, iter + counter);
                    write_score_fa(remains, score_mat);
                }
                inner_counters[thread_id] = 0U;
            }
            omp_unset_lock(&lock_file);

            runs_done = 0ULL;
            progressBar(1U, 1U);
            printf("\n\n");
        }
    }

    omp_destroy_lock(&lock_file);

    Mat_Close(score_mat);

    return EXIT_SUCCESS;
}
